# defines wrappers for the builtin Tensor type
from random import random_float64, seed
from tensor import TensorShape

alias float: DType = DType.float64

trait TensorWrapper:

	fn __init__(inout self) raises:
		...

	fn __copyinit__(inout self, borrowed other: Self):
		...
	
	fn __moveinit__(inout self, owned other: Self):
		...

trait MDTensorWrapper(TensorWrapper):
  
  """
  TensorWrappers conforming to this trait have more than one Dimension 
  and can be flattened out to a Vector.
  """
  fn flatten(inout self) raises -> Vector:
    ...

# defines a wrapper to handle mathematical vectors
struct Vector(TensorWrapper, Sized):
  
  var data: Tensor[float]
  var size: Int
  var _offset: Int

  fn __init__(inout self) raises:
    self.size = 0
    self._offset = 0
    self.data = Tensor[float]()

  fn __init__(inout self, owned size: Int) raises:
    self.size = size
    self._offset = 0
    self.data = Tensor[float](size)

  fn __init__(inout self, owned data: Tensor[float]) raises:
    if data.rank() != 1:
      raise Error("Unable to convert given data to a vector due to rank mismatch")
    self.data = data
    self._offset = 0
    self.size = data.dim(0)

  fn __copyinit__(inout self, borrowed other: Self):
    self.data = other.data
    self._offset = other._offset
    self.size = other.size

  fn __moveinit__(inout self, owned other: Self):
    self.data = other.data
    self._offset = other._offset
    self.size = other.size

  fn __getitem__(self, index: Int) -> Float64:
    return self.data[index]

  fn __len__(self) -> Int:
    return self.size

  fn __iter__(self) raises -> Vector:
    return self.data

  fn __next__(inout self) raises -> Float64:
    if self._offset >= self.size:
      raise Error("Index out of range of vector")
    self._offset += 1
    return self.data[self._offset]

  fn __mul__(borrowed self, vec: Vector) raises -> Float64:
    return (self.data * vec.data)[0]

  fn __add__(self, vec: Vector) raises -> Vector:
    if  vec.data.dim(0) != self.data.dim(0):
      raise Error("Unable to add vectors due to dimension mismatch")
    var val = Vector()
    for i in range(self.data.dim(0)):
      val.append(
        self.data[i] + vec.data[i]
      )
    return val

  fn append(inout self, data: Float64) raises:
    self.data = self.data.reshape(
      TensorShape(
        self.data.shape().num_elements()+1
        )
      )
    self.data.simd_store(-1, data)

  # defines function for generating random vectors with Float64 values
  fn random_vector(inout self, len: Int) raises:
    self.data = Tensor[float](len)
    seed()
    for i in range(len):
      self.data.simd_store[1](i, random_float64())

  # takes a function and returns its equivalent for the Vector type
  @staticmethod
  fn vector_applicable(func: fn(Float64) -> Float64) -> fn(Vector) raises escaping -> Vector:
    @always_inline
    fn vecfunc(vec: Vector) raises escaping -> Vector:
      var val = Vector()
      for i in vec:
        val.append(func(i))
      return val
    
    return vecfunc

  # takes a function with a parameter and returns it equivalent for the Vector type
  @staticmethod
  fn vector_applicable(func: fn(a:Float64, x:Float64) -> Float64) -> fn(a:Float64, vec:Vector) raises escaping -> Vector:
    @always_inline
    fn vecfunc(a:Float64, vec: Vector) raises -> Vector:
      var val = Vector()
      for i in vec:
        val.append(func(a, i))
      return val
    
    return vecfunc

# defines an alias for pointers to the Vector type
alias VectorP = Pointer[Vector]

# defines a wrapper to handle mathematical matrices
struct Matrix(MDTensorWrapper):

  var data: Tensor[float]
  var x: Int
  var y: Int

  fn __init__(inout self) raises:
    self.data = Tensor[float]()
    self.x = 0
    self.y = 0

  fn __init__(inout self, owned x: Int, owned y: Int):
    self.x = x
    self.y = y
    self.data = Tensor[float](x, y)

  fn __init__(inout self, owned data: Tensor[float]) raises:
    if data.rank() != 2:
      raise Error("Unable to convert given data to a matrix due to rank mismatch")
    self.data = data
    self.x = data.dim(0)
    self.y = data.dim(1)

  fn __copyinit__(inout self, borrowed other: Self):
    self.data = other.data
    self.x = other.x
    self.y = other.y

  fn __moveinit__(inout self, owned other: Self):
    self.data = other.data
    self.x = other.x
    self.y = other.y

  # defines function for matrix-vector multiplication
  fn __mul__(borrowed self, vec: Vector) raises-> Vector:
    if vec.data.dim(0) != self.data.dim(1):
      raise Error("Cannot multiply due to dimension mismatch")

    var val = Vector(self.data.dim(0))

    for i in range(self.data.dim(0)):
      # multiplies input vector with rows of matrix
      val.data[i] = vec * 
        Vector(
          # returns the i-th row of the matrix as Tensor value
          self.data.clip(
            self.data.dim(1)*i, 
            self.data.dim(1)*(i+1)-1
          )
        )
    
    return val

  # defines function for matrix-vector multiplication
  fn __rmul__(borrowed self, vec: Vector) raises-> Vector:
    return self.__mul__(vec)

  fn flatten(inout self) raises -> Vector:
    return Vector(self.data.reshape(TensorShape(self.x * self.y)))

  # defines function for generating random matrices with Float64 values
  fn random_matrix(inout self, x: Int, y: Int) raises:
 
    self.data = Tensor[float](x, y)
    
    seed()
    
    for i in range(x):
      for j in range(y):
        self.data.simd_store[1](
          VariadicList(i, j), 
          random_float64()
          )

  # takes a function with a parameter and returns it equivalent for the Matrix type
  @staticmethod
  fn matrix_applicable(func: fn(Float64) -> Float64) -> fn(Matrix) raises escaping -> Matrix:
    @always_inline
    fn matfunc(matrix: Matrix) raises escaping -> Matrix:
      var val = Matrix()
      return val
    
    return matfunc

# defines an alias for pointers to the matrix type
alias MatrixP = Pointer[Matrix]

# defines a wrapper to handle mathematical 3-dimensional tensors
struct Tensor3D(MDTensorWrapper):
  
  var x: Int
  var y: Int
  var z: Int
  var data: Tensor[float]

  fn __init__(inout self) raises:
    self.data = Tensor[float]()
    self.x = 0
    self.y = 0
    self.z = 0

  fn __init__(inout self, owned x: Int, owned y: Int, owned z: Int):
    self.x = x
    self.y = y
    self.z = z
    self.data = Tensor[float](x,y,z)

  fn __init__(inout self, owned data: Tensor[float]) raises:
    
    if data.rank() != 3:
      raise Error("Unable to convert given data to a matrix due to rank mismatch")
    self.data = data
    self.x = data.dim(0)
    self.y = data.dim(1)
    self.z = data.dim(2)

  fn __copyinit__(inout self, borrowed other: Self):
    self.data = other.data
    self.x = other.x
    self.y = other.y
    self.z = other.z

  fn __moveinit__(inout self, owned other: Self):
    self.data = other.data
    self.x = other.x
    self.y = other.y
    self.z = other.z

  fn flatten(inout self) raises -> Vector:
    return Vector(self.data.reshape(TensorShape(self.x * self.y * self.z)))

  fn random_tensor3d(inout self, owned x: Int, owned y: Int, owned z: Int):
    pass

alias Tensor3DP = Pointer[Tensor3D]
